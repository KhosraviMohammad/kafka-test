syntax = "proto3";

package emqx.exhook.v2;

service HookProvider {

  rpc OnProviderLoaded(ProviderLoadedRequest) returns (LoadedResponse) {};

  rpc OnProviderUnloaded(ProviderUnloadedRequest) returns (EmptySuccess) {};

  rpc OnClientConnect(ClientConnectRequest) returns (EmptySuccess) {};

  rpc OnClientAuthenticate(ClientAuthenticateRequest) returns (ValuedResponse) {};

  rpc OnClientAuthorize(ClientAuthorizeRequest) returns (ValuedResponse) {};
}

// Provider Loaded Request
message ProviderLoadedRequest {
  BrokerInfo broker = 1;
  RequestMeta meta = 2;
}

// Provider Unloaded Request
message ProviderUnloadedRequest {
  RequestMeta meta = 1;
}

// Client Connect Request
message ClientConnectRequest {
  ConnInfo conninfo = 1;
  repeated Property props = 2;
  RequestMeta meta = 3;
  repeated Property user_props = 4;
}

// Client Authenticate Request
message ClientAuthenticateRequest {
  ClientInfo clientinfo = 1;
  bool result = 2;
  RequestMeta meta = 3;
}

message ClientAuthorizeRequest {

  ClientInfo clientinfo = 1;

  enum AuthorizeReqType {

    PUBLISH = 0;

    SUBSCRIBE = 1;
  }

  AuthorizeReqType type = 2;

  // In ClientAuthorizeRequest.
  // Only "real-topic" will be serialized in gRPC request when shared-sub.
  // For example, when client subscribes to `$share/group/t/1`, the real topic is `t/1`.
  string topic = 3;

  bool result = 4;

  RequestMeta meta = 5;
}

// Response types
message LoadedResponse {
  repeated HookSpec hooks = 1;
}

message HookSpec {

  // The registered hooks name
  //
  // Available value:
  //   "client.connect",      "client.connack"
  //   "client.connected",    "client.disconnected"
  //   "client.authenticate", "client.authorize"
  //   "client.subscribe",    "client.unsubscribe"
  //
  //   "session.created",      "session.subscribed"
  //   "session.unsubscribed", "session.resumed"
  //   "session.discarded",    "session.takenover"
  //   "session.terminated"
  //
  //   "message.publish", "message.delivered"
  //   "message.acked",   "message.dropped"
  string name = 1;

  // The topic filters for message hooks
  repeated string topics = 2;
}

message ValuedResponse {
  enum ResponsedType {
    CONTINUE = 0;
    IGNORE = 1;
    STOP_AND_RETURN = 2;
  }
  ResponsedType type = 1;
  oneof value {

    bool bool_result = 3;

    Message message = 4;
  }
}

message Message {

  string node = 1;

  string id = 2;

  uint32 qos = 3;

  string from = 4;

  string topic = 5;

  bytes  payload = 6;

  uint64 timestamp = 7;

  // The key of header can be:
  //  - username:
  //    * Readonly
  //    * The username of sender client
  //    * Value type: utf8 string
  //  - protocol:
  //    * Readonly
  //    * The protocol name of sender client
  //    * Value type: string enum with "mqtt", "mqtt-sn", ...
  //  - peerhost:
  //    * Readonly
  //    * The peerhost of sender client
  //    * Value type: ip address string
  //  - allow_publish:
  //    * Writable
  //    * Whether to allow the message to be published by emqx
  //    * Value type: string enum with "true", "false", default is "true"
  //
  // Notes: All header may be missing, which means that the message does not
  //   carry these headers. We can guarantee that clients coming from MQTT,
  //   MQTT-SN, CoAP, LwM2M and other natively supported protocol clients will
  //   carry these headers, but there is no guarantee that messages published
  //   by other means will do, e.g. messages published by HTTP-API
  map<string, string> headers = 8;
}
message EmptySuccess {}

// Common message types
message BrokerInfo {
  string version = 1;
  string sysdescr = 2;
  uint64 uptime = 3;
  string datetime = 4;
}

message RequestMeta {
  string node = 1;
  string version = 2;
  string sysdescr = 3;
  string cluster_name = 4;
}

message Property {
  string name = 1;
  string value = 2;
}

message ClientInfo {
  string node = 1;
  string clientid = 2;
  string username = 3;
  string password = 4;
  string peerhost = 5;
  uint32 sockport = 6;
  string protocol = 7;
  string mountpoint = 8;
  bool is_superuser = 9;
  bool anonymous = 10;
  string cn = 11;
  string dn = 12;
  uint32 peerport = 13;
}

message ConnInfo {
  string node = 1;
  string clientid = 2;
  string username = 3;
  string peerhost = 4;
  uint32 sockport = 5;
  string proto_name = 6;
  string proto_ver = 7;
  uint32 keepalive = 8;
  uint32 peerport = 9;
}
